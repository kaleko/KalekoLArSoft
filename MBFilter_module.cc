////////////////////////////////////////////////////////////////////////
// Class:       MBFilter
// Module Type: filter
// File:        MBFilter_module.cc
//
// Generated at Thurs Oct 8, 2015 by Kaleko copying Kazu's stuff
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <memory>

#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTruth.h"
#include "RecoBase/OpFlash.h"
#include "Geometry/Geometry.h"
#include <limits>
#include <climits>
#include <TFile.h>
#include <TString.h>
#include <TTree.h>
#include <TH1D.h>
#include <TGraphErrors.h>
#include <string>
#include <iostream>
#include <vector>
class MBFilter;

class MBFilter : public art::EDFilter {
public:
  explicit MBFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MBFilter(MBFilter const &) = delete;
  MBFilter(MBFilter &&) = delete;
  MBFilter & operator = (MBFilter const &) = delete;
  MBFilter & operator = (MBFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;
  void endJob();

private:

  //
  // Module utility variables
  //
  std::string _gen_module;   ///< simb::MCTruth producer module label
  bool        _verbose;      ///< Verbosity flag
  double      _event_ctr;    ///< A counter for the total number of events processed

  // Particles I don't care about
  std::vector<size_t> _pdgs_to_ignore = {
    12, //nue
    2112, //neutrons
    2000000101, // genie::kPdgBindino
  };

  // Map going from PDG to cherenkov threshold ENERGY (MeV/c^2) in CH2
  // These values taken from Georgia's thesis (they include mass) and Jocelyn Monroe's thesis
  //
  std::map<size_t, float> _cherenk_thresholds_MEV =
  { {11, 0.7},      /// e  ==> 0.7 MeV or 0.5 MeV/c
    {211, 190.},    /// pi ==> 190 MeV or 128 MeV/c
    {13, 144.},     /// mu ==> 144 MeV or 98 MeV/c
    {2212, 1280.},  /// p  ==> 1280 MeV or 872 MeV/c
    {111, 184.},    /// pi0 ==> 184 MeV/c^2 or 126 MeV/c
    {3122, -1.},    /// lambda baryon? at any energy, throw this event away (note: still ignored if below min vis energy)
    {321, -1.}      /// K+? same as lambda baryon
  };

  // Georgia's thesis says:
  // "A minimum visible energy cut, Evis = Ee âˆ’ me > 140 MeV, is required to reject NC events"
  float _min_vis_energy_MEV = 140.;

  // Georgia's thesis says:
  // "An additional kinematics-based cut is used to reject mis-identified events due to interactions
  // that take place outside the detector, or close to the fiducial volume boundary."
  // ********* implement this fiducial volume cut! *********

  //For this filter, just reject events with an electron above 1.5 GeV... they definitely aren't part of the low energy excess
  float _max_electron_energy_MEV = 1500.;

  // Output simple tree contents
  //
  bool _save_tree;           ///< Boolean to save analysis TTree or not
  TTree* _mbfilter_tree;
  unsigned int _run;         ///< Run ID
  unsigned int _subrun;      ///< SubRun ID
  unsigned int _event;       ///< Event ID
  double _nu_mc_x;           ///< Neutrino MC X position
  double _nu_mc_y;           ///< Neutrino MC Y position
  double _nu_mc_z;           ///< Neutrino MC Z position

  //
  // Attribute functions
  //
  void EventClear();             ///< Clear event-wise variables
  void MakeTree();               ///< Make TTree
};


MBFilter::MBFilter(fhicl::ParameterSet const & p)
  : _mbfilter_tree(nullptr)
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  //
  // Module utility
  //
  _verbose                   = p.get< bool         > ( "Verbose"                 );
  _gen_module                = p.get< std::string  > ( "NeutrinoGenerator"       );

  //
  // Analysis configuration
  //
  _save_tree   = p.get< bool > ( "SaveTree"   );
}

void MBFilter::MakeTree()
{
  art::ServiceHandle<art::TFileService> tfs;
  _mbfilter_tree = tfs->make<TTree>("mbfilter_tree", "MBFilter Module Analysis Tree");

  // Instantiate size of pe vector (# of opdet)
  art::ServiceHandle<geo::Geometry> geom;

  // Simple type branch
  _mbfilter_tree->Branch ( "run",      &_run,      "run/i"      );
  _mbfilter_tree->Branch ( "subrun",   &_subrun,   "subrun/i"   );
  _mbfilter_tree->Branch ( "event",    &_event,    "event/i"    );
  _mbfilter_tree->Branch ( "nu_mc_x",  &_nu_mc_x,  "mc_nu_x/D"  );
  _mbfilter_tree->Branch ( "nu_mc_y",  &_nu_mc_y,  "mc_nu_y/D"  );
  _mbfilter_tree->Branch ( "nu_mc_z",  &_nu_mc_z,  "mc_nu_z/D"  );
}

void MBFilter::EventClear()
{
  _run = _subrun = _event = 0;
  _nu_mc_x = _nu_mc_y = _nu_mc_z = std::numeric_limits<double>::max();
}


bool MBFilter::filter(art::Event & e)
{

  bool return_value = true;
  size_t n_electrons = 0;
  size_t n_additional_subevents = 0;
  //
  // Analysis preparation
  //
  if (_save_tree) {

    if (!_mbfilter_tree) MakeTree();

    EventClear();
  }

  //
  // Event-wise variable
  //
  _run    = e.id().run();
  _subrun = e.id().subRun();
  _event  = e.id().event();
  _event_ctr += 1; // Increment total event ctr

  // Retrieve Neutrino Interaction Info
  art::Handle< std::vector< simb::MCTruth > > mct_handle;
  e.getByLabel( _gen_module, mct_handle );
  if (mct_handle.isValid() && mct_handle->size()) {
    bool nu_set = false;
    if ( mct_handle->size() != 1 )
      std::cout << "\n\n\n\n\n\n\n i have no idea what is going on. mct size is " << mct_handle->size() << "\n\n\n\n\n\n\n" << std::endl;


    for (auto const& mct : (*mct_handle)) {

      if (mct.Origin() != simb::kBeamNeutrino) {
        std::cout << "\n\n\n\n\n\n\n wtf mct.Origin() is not simb::kBeamNeutrino?!?!?! \n\n\n\n\n\n\n\n\n" << std::endl;
        continue;
      }

      if (_verbose)
        std::cout << "MBFilter looping over " << mct.NParticles() << " particles in this event... " << std::endl;

      /// Loop over particles coming from the neutrino interaction, and filter the event if this event wouldn't pass miniboone cuts
      /// IE based on number of electrons, number of subevents (above cherenkov threshold), etc
      for (size_t part_index = 0; part_index < (size_t)(mct.NParticles()); ++part_index) {
        auto const& part = mct.GetParticle(part_index);

        // MBFilter looping over 9 particles in this event...
        // Particle 0 has PDG 12 and StatusCode 0.
        // Particle 1 has PDG 1000180400 and StatusCode 0.
        // Particle 2 has PDG 2112 and StatusCode 11.
        // Particle 3 has PDG 1000180390 and StatusCode 2.
        // Particle 4 has PDG 11 and StatusCode 1.
        // Particle 5 has PDG 2212 and StatusCode 14.
        // Particle 6 has PDG 2212 and StatusCode 1.
        // Particle 7 has PDG 2000000002 and StatusCode 15.
        // Particle 8 has PDG 2000000101 and StatusCode 1.

        //Note, when counting final state particles, ignore any particles that don't have status code == 1
        if (part.StatusCode() != 1) continue;

        double E_MEV  = part.Trajectory().E(0) * 1000.;
        size_t PDG = abs(part.PdgCode());

        if (_verbose)
          std::cout << "\t Particle " << part_index
                    << "\tPDG " << PDG
                    << "\tStatusCode " << part.StatusCode()
                    << "\tEnergy " << E_MEV
                    << "." << std::endl;

        //If this PDG is one that I want to ignore in this filter, continue
        if (std::find(_pdgs_to_ignore.begin(), _pdgs_to_ignore.end(), PDG) != _pdgs_to_ignore.end()) {
          if (_verbose)
            std::cout << " Ignoring this particle!" << std::endl;
          continue;
        }

        //Make sure I have a recorded cherenkov threshold for this type of particle
        if (!_cherenk_thresholds_MEV.count(PDG)) 
          throw std::invalid_argument( Form("PDG %zu not in std::map of cherenkov thresholds!", PDG) );

        // If this particle is an electron above like 1.5 GeV, it's not part of the low energy excess... just skip event
        if ( E_MEV > _max_electron_energy_MEV )
          return false;

        // If this particle is below cherenkov threshold, ignore it
        if ( E_MEV < _cherenk_thresholds_MEV[PDG]) {
          if (_verbose) std::cout << " This particle below cherenkov threshold!" << std::endl;
          continue;
        }

        //If this particle is an electron above minimum energy cut, count it
        if (PDG == 11 && E_MEV > _min_vis_energy_MEV) n_electrons++;
        else n_additional_subevents++;

        // I think this is the neutrino information? Store it in ttree.
        if (part.StatusCode() == 1 && !nu_set) {
          _nu_mc_x = part.Position(0)[0];
          _nu_mc_y = part.Position(0)[1];
          _nu_mc_z = part.Position(0)[2];
          nu_set = true;
        }
      } // End loop over particles
    } // End loop over (1) mctruths
  } // End if mctruth handle is valid

  if (_verbose) std::cout << " # of electrons = " << n_electrons << ", # of additional subevents = " << n_additional_subevents << std::endl;

  if (n_electrons != 1 || n_additional_subevents)
    return_value = false;

  _mbfilter_tree->Fill();
  return return_value;

} // End MBFilter::filter()

void MBFilter::endJob()
{
  if (!_mbfilter_tree) return;
}

DEFINE_ART_MODULE(MBFilter)
